package github

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/acctest"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
)

func TestAccGithubTeamSettings(t *testing.T) {
	t.Run("manages team settings can use team_id id and slug", func(t *testing.T) {
		randomID := acctest.RandStringFromCharSet(5, acctest.CharSetAlphaNum)
		teamName := fmt.Sprintf("%steam-settings-%s", testResourcePrefix, randomID)
		config := fmt.Sprintf(`
			resource "github_team" "test" {
				name        = "%s"
				description = "generated by terraform provider automated testing"
			}

			resource "github_team_settings" "test" {
				team_id    = "${github_team.test.id}"
			}
		`, teamName)

		check := resource.ComposeTestCheckFunc(
			resource.TestCheckResourceAttrSet("github_team_settings.test", "team_id"),
		)

		resource.Test(t, resource.TestCase{
			PreCheck:          func() { skipUnlessHasOrgs(t) },
			ProviderFactories: providerFactories,
			Steps: []resource.TestStep{
				{
					Config: config,
					Check:  check,
				},
				{
					Config: strings.Replace(config,
						`github_team.test.id`,
						`github_team.test.slug`, 1),
					Check: check,
				},
			},
		})
	})

	t.Run("manages team code review settings", func(t *testing.T) {
		randomID := acctest.RandStringFromCharSet(5, acctest.CharSetAlphaNum)
		teamName := fmt.Sprintf("%steam-settings-%s", testResourcePrefix, randomID)
		config := fmt.Sprintf(`
			resource "github_team" "test" {
				name        = "%s"
				description = "generated by terraform provider automated testing"
			}

			resource "github_team_settings" "test" {
				team_id    = "${github_team.test.id}"
				review_request_delegation {
					algorithm = "ROUND_ROBIN"
					member_count = 1
					notify = true
				}
			}
		`, teamName)

		checks := map[string]resource.TestCheckFunc{
			"round_robin": resource.ComposeTestCheckFunc(
				resource.TestCheckResourceAttr(
					"github_team_settings.test", "review_request_delegation.0.algorithm",
					"ROUND_ROBIN",
				),
			),
			"load_balance": resource.ComposeTestCheckFunc(
				resource.TestCheckResourceAttr(
					"github_team_settings.test", "review_request_delegation.0.algorithm",
					"LOAD_BALANCE",
				),
			),
			"review_count": resource.ComposeTestCheckFunc(
				resource.TestCheckResourceAttr(
					"github_team_settings.test", "review_request_delegation.0.member_count",
					"3",
				),
			),
			"notify": resource.ComposeTestCheckFunc(
				resource.TestCheckResourceAttr(
					"github_team_settings.test", "review_request_delegation.0.notify",
					"false",
				),
			),
		}

		resource.Test(t, resource.TestCase{
			PreCheck:          func() { skipUnlessHasOrgs(t) },
			ProviderFactories: providerFactories,
			Steps: []resource.TestStep{
				{
					Config: config,
					Check:  checks["round_robin"],
				},
				{
					Config: strings.Replace(config,
						`algorithm = "ROUND_ROBIN"`,
						`algorithm = "LOAD_BALANCE"`, 1),
					Check: checks["load_balance"],
				},
				{
					Config: strings.Replace(config,
						`member_count = 1`,
						`member_count = 3`, 1),
					Check: checks["review_count"],
				},
				{
					Config: strings.Replace(config,
						`notify = true`,
						`notify = false`, 1),
					Check: checks["notify"],
				},
			},
		})
	})

	t.Run("manages team code review settings with excluded members", func(t *testing.T) {
		randomID := acctest.RandStringFromCharSet(5, acctest.CharSetAlphaNum)
		teamName := fmt.Sprintf("%steam-settings-%s", testResourcePrefix, randomID)
		config := fmt.Sprintf(`
			resource "github_team" "test" {
				name        = "%s"
				description = "generated by terraform provider automated testing"
			}

			resource "github_team_settings" "test" {
				team_id    = "${github_team.test.id}"
				review_request_delegation {
					algorithm = "ROUND_ROBIN"
					member_count = 1
					notify = true
					excluded_members = ["octocat", "defunkt"]
				}
			}
		`, teamName)

		check := resource.ComposeTestCheckFunc(
			resource.TestCheckResourceAttr(
				"github_team_settings.test", "review_request_delegation.0.algorithm",
				"ROUND_ROBIN",
			),
			resource.TestCheckResourceAttr(
				"github_team_settings.test", "review_request_delegation.0.excluded_members.#",
				"2",
			),
		)

		resource.Test(t, resource.TestCase{
			PreCheck:          func() { skipUnlessHasOrgs(t) },
			ProviderFactories: providerFactories,
			Steps: []resource.TestStep{
				{
					Config: config,
					Check:  check,
				},
			},
		})
	})

	t.Run("cannot manage team code review settings if disabled", func(t *testing.T) {
		randomID := acctest.RandStringFromCharSet(5, acctest.CharSetAlphaNum)
		teamName := fmt.Sprintf("%steam-settings-%s", testResourcePrefix, randomID)
		config := fmt.Sprintf(`
			resource "github_team" "test" {
				name        = "%s"
				description = "generated by terraform provider automated testing"
			}

			resource "github_team_settings" "test" {
				team_id    = "${github_team.test.id}"
				review_request_delegation {
					algorithm = "ROUND_ROBIN"
					member_count = 1
					notify = true
				}
			}
		`, teamName)

		resource.Test(t, resource.TestCase{
			PreCheck:          func() { skipUnlessHasOrgs(t) },
			ProviderFactories: providerFactories,
			Steps: []resource.TestStep{
				{
					Config: strings.Replace(config,
						`algorithm = "ROUND_ROBIN"`,
						`algorithm = "invalid"`, 1),
					ExpectError: regexp.MustCompile(`review request delegation algorithm must be one of \[.*\]`),
				},
			},
		})
	})
}

func TestBatchUserNodeIds(t *testing.T) {
	t.Run("fetches user node IDs in batch", func(t *testing.T) {
		if len(testAccConf.testExternalUser) == 0 {
			t.Skip("No external user provided")
		}

		// Skip if not authenticated
		skipUnauthenticated(t)

		// Create a test owner/meta object
		owner, err := getTestMeta()
		if err != nil {
			t.Fatalf("Failed to get test meta: %v", err)
		}

		ctx := context.Background()

		// Test with single user
		t.Run("single user", func(t *testing.T) {
			usernames := []string{testAccConf.testExternalUser}
			result, err := getBatchUserNodeIds(ctx, owner, usernames)

			if err != nil {
				t.Fatalf("getBatchUserNodeIds failed: %v", err)
			}

			if len(result) != 1 {
				t.Errorf("Expected 1 result, got %d", len(result))
			}

			nodeId, exists := result[testAccConf.testExternalUser]
			if !exists {
				t.Errorf("Expected node ID for user %s", testAccConf.testExternalUser)
			}

			if nodeId == "" {
				t.Errorf("Node ID should not be empty")
			}

			t.Logf("Successfully fetched node ID %s for user %s", nodeId, testAccConf.testExternalUser)
		})

		// Test with multiple users (using same user multiple times for simplicity)
		t.Run("multiple users", func(t *testing.T) {
			usernames := []string{testAccConf.testExternalUser, "octocat"} // octocat is a well-known GitHub user
			result, err := getBatchUserNodeIds(ctx, owner, usernames)

			if err != nil {
				t.Fatalf("getBatchUserNodeIds failed: %v", err)
			}

			// We expect at least the test user to exist
			if len(result) == 0 {
				t.Errorf("Expected at least 1 result, got %d", len(result))
			}

			// Check that our test user exists
			nodeId, exists := result[testAccConf.testExternalUser]
			if !exists {
				t.Errorf("Expected node ID for user %s", testAccConf.testExternalUser)
			} else if nodeId == "" {
				t.Errorf("Node ID should not be empty")
			}

			t.Logf("Successfully fetched %d node IDs in batch request", len(result))
			for username, nodeId := range result {
				t.Logf("  User: %s, Node ID: %s", username, nodeId)
			}
		})

		// Test with empty list
		t.Run("empty usernames list", func(t *testing.T) {
			usernames := []string{}
			result, err := getBatchUserNodeIds(ctx, owner, usernames)

			if err != nil {
				t.Fatalf("getBatchUserNodeIds failed: %v", err)
			}

			if len(result) != 0 {
				t.Errorf("Expected 0 results for empty list, got %d", len(result))
			}
		})

		// Test with non-existent user
		t.Run("non-existent user", func(t *testing.T) {
			nonExistentUser := "this-user-definitely-does-not-exist-12345"
			usernames := []string{nonExistentUser}
			result, err := getBatchUserNodeIds(ctx, owner, usernames)

			if err != nil {
				t.Fatalf("getBatchUserNodeIds failed: %v", err)
			}

			// Non-existent users should not appear in results
			if len(result) != 0 {
				t.Errorf("Expected 0 results for non-existent user, got %d", len(result))
			}
		})
	})
}
