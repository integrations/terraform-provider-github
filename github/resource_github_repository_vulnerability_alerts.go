package github

import (
	"context"
	"fmt"
	"strconv"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceGithubRepositoryVulnerabilityAlerts() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceGithubRepositoryVulnerabilityAlertsCreate,
		ReadContext:   resourceGithubRepositoryVulnerabilityAlertsRead,
		UpdateContext: resourceGithubRepositoryVulnerabilityAlertsUpdate,
		DeleteContext: resourceGithubRepositoryVulnerabilityAlertsDelete,
		Importer: &schema.ResourceImporter{
			StateContext: resourceGithubRepositoryVulnerabilityAlertsImport,
		},

		Schema: map[string]*schema.Schema{
			"repository": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "The repository name to configure vulnerability alerts for.",
			},
			"repository_id": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "The ID of the repository to configure vulnerability alerts for.",
			},
			"owner": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "The owner of the repository to configure vulnerability alerts for.",
			},
			"enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     true,
				Description: "Whether vulnerability alerts are enabled for the repository.",
			},
		},

		CustomizeDiff: diffRepository,
	}
}

func resourceGithubRepositoryVulnerabilityAlertsCreate(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	meta := m.(*Owner)
	client := meta.v3client

	owner := d.Get("owner").(string)
	repoName := d.Get("repository").(string)

	vulnerabilityAlertsEnabled := d.Get("enabled").(bool)
	if vulnerabilityAlertsEnabled {
		_, err := client.Repositories.EnableVulnerabilityAlerts(ctx, owner, repoName)
		if err != nil {
			return diag.FromErr(err)
		}
	} else {
		_, err := client.Repositories.DisableVulnerabilityAlerts(ctx, owner, repoName)
		if err != nil {
			return diag.FromErr(err)
		}
	}
	repo, _, err := client.Repositories.Get(ctx, owner, repoName)
	if err != nil {
		return diag.FromErr(err)
	}
	if err = d.Set("repository_id", repo.GetID()); err != nil {
		return diag.FromErr(err)
	}

	id, err := buildID(owner, strconv.Itoa(int(repo.GetID())))
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)

	return nil
}

func resourceGithubRepositoryVulnerabilityAlertsRead(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	meta := m.(*Owner)
	client := meta.v3client

	owner := d.Get("owner").(string)
	repoName := d.Get("repository").(string)
	vulnerabilityAlertsEnabled, _, err := client.Repositories.GetVulnerabilityAlerts(ctx, owner, repoName)
	if err != nil {
		return diag.Errorf("error reading repository vulnerability alerts: %s", err.Error())
	}
	if err = d.Set("enabled", vulnerabilityAlertsEnabled); err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceGithubRepositoryVulnerabilityAlertsUpdate(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	meta := m.(*Owner)
	client := meta.v3client

	owner := d.Get("owner").(string)
	repoName := d.Get("repository").(string)

	vulnerabilityAlertsEnabled := d.Get("enabled").(bool)
	if vulnerabilityAlertsEnabled {
		_, err := client.Repositories.EnableVulnerabilityAlerts(ctx, owner, repoName)
		if err != nil {
			return diag.FromErr(err)
		}
	} else {
		_, err := client.Repositories.DisableVulnerabilityAlerts(ctx, owner, repoName)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	return nil
}

func resourceGithubRepositoryVulnerabilityAlertsDelete(ctx context.Context, d *schema.ResourceData, m any) diag.Diagnostics {
	meta := m.(*Owner)
	client := meta.v3client

	owner := d.Get("owner").(string)
	repoName := d.Get("repository").(string)
	_, err := client.Repositories.DisableVulnerabilityAlerts(ctx, owner, repoName)
	if err != nil {
		return diag.FromErr(handleArchivedRepoDelete(err, "repository vulnerability alerts", d.Id(), owner, repoName))
	}

	return nil
}

func resourceGithubRepositoryVulnerabilityAlertsImport(ctx context.Context, d *schema.ResourceData, m any) ([]*schema.ResourceData, error) {
	tflog.Debug(ctx, "Importing repository vulnerability alerts", map[string]any{"id": d.Id()})
	repoOwner, repoName, err := parseID2(d.Id())
	if err != nil {
		return nil, fmt.Errorf("invalid ID specified: supplied ID must be written as <repository_owner>:<repository_name>. Original error: %w", err)
	}
	if err := d.Set("owner", repoOwner); err != nil {
		return nil, err
	}
	if err := d.Set("repository", repoName); err != nil {
		return nil, err
	}

	meta := m.(*Owner)
	client := meta.v3client

	repo, _, err := client.Repositories.Get(ctx, repoOwner, repoName)
	if err != nil {
		return nil, err
	}
	if err = d.Set("repository_id", repo.GetID()); err != nil {
		return nil, err
	}

	id, err := buildID(repoOwner, strconv.Itoa(int(repo.GetID())))
	if err != nil {
		return nil, err
	}

	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}
